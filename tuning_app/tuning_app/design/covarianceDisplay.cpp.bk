#include <QVBoxLayout>
#include <cmath>
#include "covarianceDisplay.hpp"

using namespace rom_dynamics;


rom_dynamics::ui::qt::RomCovarianceGraph::RomCovarianceGraph(QWidget *parent)
    : QWidget(parent)
{
    // 1. Initialize Chart
    initializeChart();

    // 2. Setup Layout
    QVBoxLayout *layout = new QVBoxLayout(this);
    layout->addWidget(chart_view_position_);
    setLayout(layout);
    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
}

rom_dynamics::ui::qt::RomCovarianceGraph::~RomCovarianceGraph()
{
    // Cleanup if necessary
}


void rom_dynamics::ui::qt::RomCovarianceGraph::initializeChart()
{
    // Chart for X-Y Position Ellipse
    chart_position_ = new QChart();
    chart_position_->setTitle("EKF Position Covariance x & y");
    
    ellipse_series_ = new QScatterSeries();
    ellipse_series_->setMarkerSize(3.0);
    ellipse_series_->setColor(QColor(255, 0, 0)); // Red for the ellipse points
    ellipse_series_->setName("95% Confidence Ellipse");

    chart_position_->legend()->hide();

    chart_position_->addSeries(ellipse_series_);

    // Axis setup (Fixed range for visualization)
    axisX_ = new QValueAxis();
    axisX_->setRange(-1.0, 1.0);
    axisY_ = new QValueAxis();
    axisY_->setRange(-1.0, 1.0);
    chart_position_->addAxis(axisX_, Qt::AlignBottom);
    chart_position_->addAxis(axisY_, Qt::AlignLeft);
    ellipse_series_->attachAxis(axisX_);
    ellipse_series_->attachAxis(axisY_);

    // --- Initialize Yaw Arc Series ---
    yaw_arc_series_ = new QLineSeries();
    yaw_arc_series_->setColor(QColor(0, 0, 255)); // Blue for yaw
    QPen pen = yaw_arc_series_->pen();
    pen.setWidth(2);
    yaw_arc_series_->setPen(pen);
    yaw_arc_series_->setName("Yaw 2σ Uncertainty");

    chart_position_->addSeries(yaw_arc_series_);
    yaw_arc_series_->attachAxis(axisX_);
    yaw_arc_series_->attachAxis(axisY_);
    // --- End Yaw Arc Series Setup ---
    
    chart_view_position_ = new QChartView(chart_position_);
    chart_view_position_->setRenderHint(QPainter::Antialiasing);
}

void rom_dynamics::ui::qt::RomCovarianceGraph::updateCovarianceGraph(double ekf_pose_x, 
        double ekf_pose_y, 
        double ekf_pose_yaw, 
        double xx_cov, 
        double xy_cov, 
        double yx_cov, 
        double yy_cov, 
        double yaw_cov)
{
    current_x_ = ekf_pose_x;
    current_y_ = ekf_pose_y;
    current_yaw_ = ekf_pose_yaw;

    current_covariance_[0]  = xx_cov;
    current_covariance_[1]  = xy_cov;
    current_covariance_[6]  = yx_cov;
    current_covariance_[7]  = yy_cov;
    current_covariance_[35] = yaw_cov;

    updateVisualization();
}

void rom_dynamics::ui::qt::RomCovarianceGraph::updateVisualization()
{
    // --- 1. Position Ellipse (2x2 Covariance) ---
    Eigen::Matrix2d covariance_xy;
    covariance_xy << current_covariance_[0], current_covariance_[1],
                     current_covariance_[6], current_covariance_[7];
    drawPositionEllipse(covariance_xy);

    // --- 2. Yaw Uncertainty (Index 35) ---
    double yaw_variance = current_covariance_[35];
    // In a real application, you would draw this on the chart_position_ too, 
    // for simplicity here we will just set the title to reflect the uncertainty
    drawYawSector(current_yaw_, yaw_variance);
}

void rom_dynamics::ui::qt::RomCovarianceGraph::drawPositionEllipse(const Eigen::Matrix2d& covariance_xy)
{
    // Calculate Eigenvalues and Eigenvectors for the Ellipse
    Eigen::EigenSolver<Eigen::Matrix2d> es(covariance_xy);
    Eigen::Vector2d eigenvalues = es.eigenvalues().real();
    Eigen::Matrix2d eigenvectors = es.eigenvectors().real();

    // Standard deviation and angle (95% confidence -> 2 standard deviations approx)
    double k = 2.4477; // Chi-squared value for 2 DOF at 95% confidence
    double major_axis = k * std::sqrt(eigenvalues(0));
    double minor_axis = k * std::sqrt(eigenvalues(1));
    double angle = std::atan2(eigenvectors(1, 0), eigenvectors(0, 0)); // Angle of major axis

    ellipse_series_->clear();
    
    // Generate Ellipse points
    const int num_points = 50;
    for (int i = 0; i <= num_points; ++i) 
    {
        double theta = 2.0 * M_PI * i / num_points;
        double x_rotated = major_axis * std::cos(theta);
        double y_rotated = minor_axis * std::sin(theta);

        // Rotate and Translate to current (x, y) pose
        double x_point = current_x_ + (x_rotated * std::cos(angle) - y_rotated * std::sin(angle));
        double y_point = current_y_ + (x_rotated * std::sin(angle) + y_rotated * std::cos(angle));

        ellipse_series_->append(x_point, y_point);
    }
    
    // Update chart view to follow the current position (optional but useful)
    double range = 0.5 + std::max(major_axis, minor_axis);
    axisX_->setRange(current_x_ - range, current_x_ + range);
    axisY_->setRange(current_y_ - range, current_y_ + range);
}

void rom_dynamics::ui::qt::RomCovarianceGraph::drawYawSector(double yaw, double yaw_variance)
{
    double sigma_yaw = std::sqrt(yaw_variance);
    // Use the 95% confidence interval (approx k=2 for normal distribution)
    double k = 2.0; 
    
    double yaw_min = yaw - k * sigma_yaw;
    double yaw_max = yaw + k * sigma_yaw;

    // Use a fixed visualization radius (e.g., 80% of the current visible range)
    double range_x = axisX_->max() - axisX_->min();
    double range_y = axisY_->max() - axisY_->min();
    double radius = 0.4 * std::min(range_x, range_y);
    
    // Safety check for radius
    if (radius < 0.01) radius = 0.1; 

    // Clear previous arc
    yaw_arc_series_->clear();

    // Start point of the arc (centered at the current pose)
    yaw_arc_series_->append(current_x_, current_y_); 

    const int num_segments = 20;
    double yaw_step = (yaw_max - yaw_min) / num_segments;

    // Generate points for the arc
    for (int i = 0; i <= num_segments; ++i) 
    {
        double current_angle = yaw_min + i * yaw_step;
        
        // Calculate the point on the circle
        double x_point = current_x_ + radius * std::cos(current_angle);
        double y_point = current_y_ + radius * std::sin(current_angle);

        yaw_arc_series_->append(x_point, y_point);
    }
    
    // End point of the arc (back to the center to close the sector)
    yaw_arc_series_->append(current_x_, current_y_);

    // Optionally update the title (keeping your original code for clarity)
    double confidence_95_deg = k * sigma_yaw * 180.0 / M_PI; 
    QString title = QString("EKF Position Covariance (X-Y)\n"
                            "Yaw Uncertainty (2σ): ±%1 degrees").arg(confidence_95_deg, 0, 'f', 2);
    chart_position_->setTitle(title);
}
